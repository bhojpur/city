// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CityServiceClient is the client API for CityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CityServiceClient interface {
	// StartLocalPlace starts a Place on the Bhojpur.NET Platform directly.
	// The incoming requests are expected in the following order:
	//   1. metadata
	//   2. all bytes constituting the city/config.yaml
	//   3. all bytes constituting the Place YAML that will be executed (that the config.yaml points to)
	//   4. all bytes constituting the gzipped Bhojpur.NET Platform application tar stream
	//   5. the Bhojpur.NET Platform application tar stream done marker
	StartLocalPlace(ctx context.Context, opts ...grpc.CallOption) (CityService_StartLocalPlaceClient, error)
	// StartFromPreviousPlace starts a new Place based on a previous one.
	// If the previous Place does not have the can-replay condition set this call will result in an error.
	StartFromPreviousPlace(ctx context.Context, in *StartFromPreviousPlaceRequest, opts ...grpc.CallOption) (*StartPlaceResponse, error)
	// StartPlaceRequest starts a new Place based on its specification.
	StartPlace(ctx context.Context, in *StartPlaceRequest, opts ...grpc.CallOption) (*StartPlaceResponse, error)
	// Searches for Place known to this instance
	ListPlace(ctx context.Context, in *ListPlaceRequest, opts ...grpc.CallOption) (*ListPlaceResponse, error)
	// Subscribe listens to new Place updates
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (CityService_SubscribeClient, error)
	// GetPlace retrieves details of a single Place
	GetPlace(ctx context.Context, in *GetPlaceRequest, opts ...grpc.CallOption) (*GetPlaceResponse, error)
	// Listen listens to Place updates and log output of a running Place
	Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (CityService_ListenClient, error)
	// StopPlace stops a currently running Place
	StopPlace(ctx context.Context, in *StopPlaceRequest, opts ...grpc.CallOption) (*StopPlaceResponse, error)
}

type cityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCityServiceClient(cc grpc.ClientConnInterface) CityServiceClient {
	return &cityServiceClient{cc}
}

func (c *cityServiceClient) StartLocalPlace(ctx context.Context, opts ...grpc.CallOption) (CityService_StartLocalPlaceClient, error) {
	stream, err := c.cc.NewStream(ctx, &CityService_ServiceDesc.Streams[0], "/v1.CityService/StartLocalPlace", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityServiceStartLocalPlaceClient{stream}
	return x, nil
}

type CityService_StartLocalPlaceClient interface {
	Send(*StartLocalPlaceRequest) error
	CloseAndRecv() (*StartPlaceResponse, error)
	grpc.ClientStream
}

type cityServiceStartLocalPlaceClient struct {
	grpc.ClientStream
}

func (x *cityServiceStartLocalPlaceClient) Send(m *StartLocalPlaceRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cityServiceStartLocalPlaceClient) CloseAndRecv() (*StartPlaceResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StartPlaceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cityServiceClient) StartFromPreviousPlace(ctx context.Context, in *StartFromPreviousPlaceRequest, opts ...grpc.CallOption) (*StartPlaceResponse, error) {
	out := new(StartPlaceResponse)
	err := c.cc.Invoke(ctx, "/v1.CityService/StartFromPreviousPlace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityServiceClient) StartPlace(ctx context.Context, in *StartPlaceRequest, opts ...grpc.CallOption) (*StartPlaceResponse, error) {
	out := new(StartPlaceResponse)
	err := c.cc.Invoke(ctx, "/v1.CityService/StartPlace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityServiceClient) ListPlace(ctx context.Context, in *ListPlaceRequest, opts ...grpc.CallOption) (*ListPlaceResponse, error) {
	out := new(ListPlaceResponse)
	err := c.cc.Invoke(ctx, "/v1.CityService/ListPlace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (CityService_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &CityService_ServiceDesc.Streams[1], "/v1.CityService/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityServiceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CityService_SubscribeClient interface {
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type cityServiceSubscribeClient struct {
	grpc.ClientStream
}

func (x *cityServiceSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cityServiceClient) GetPlace(ctx context.Context, in *GetPlaceRequest, opts ...grpc.CallOption) (*GetPlaceResponse, error) {
	out := new(GetPlaceResponse)
	err := c.cc.Invoke(ctx, "/v1.CityService/GetPlace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cityServiceClient) Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (CityService_ListenClient, error) {
	stream, err := c.cc.NewStream(ctx, &CityService_ServiceDesc.Streams[2], "/v1.CityService/Listen", opts...)
	if err != nil {
		return nil, err
	}
	x := &cityServiceListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CityService_ListenClient interface {
	Recv() (*ListenResponse, error)
	grpc.ClientStream
}

type cityServiceListenClient struct {
	grpc.ClientStream
}

func (x *cityServiceListenClient) Recv() (*ListenResponse, error) {
	m := new(ListenResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cityServiceClient) StopPlace(ctx context.Context, in *StopPlaceRequest, opts ...grpc.CallOption) (*StopPlaceResponse, error) {
	out := new(StopPlaceResponse)
	err := c.cc.Invoke(ctx, "/v1.CityService/StopPlace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CityServiceServer is the server API for CityService service.
// All implementations must embed UnimplementedCityServiceServer
// for forward compatibility
type CityServiceServer interface {
	// StartLocalPlace starts a Place on the Bhojpur.NET Platform directly.
	// The incoming requests are expected in the following order:
	//   1. metadata
	//   2. all bytes constituting the city/config.yaml
	//   3. all bytes constituting the Place YAML that will be executed (that the config.yaml points to)
	//   4. all bytes constituting the gzipped Bhojpur.NET Platform application tar stream
	//   5. the Bhojpur.NET Platform application tar stream done marker
	StartLocalPlace(CityService_StartLocalPlaceServer) error
	// StartFromPreviousPlace starts a new Place based on a previous one.
	// If the previous Place does not have the can-replay condition set this call will result in an error.
	StartFromPreviousPlace(context.Context, *StartFromPreviousPlaceRequest) (*StartPlaceResponse, error)
	// StartPlaceRequest starts a new Place based on its specification.
	StartPlace(context.Context, *StartPlaceRequest) (*StartPlaceResponse, error)
	// Searches for Place known to this instance
	ListPlace(context.Context, *ListPlaceRequest) (*ListPlaceResponse, error)
	// Subscribe listens to new Place updates
	Subscribe(*SubscribeRequest, CityService_SubscribeServer) error
	// GetPlace retrieves details of a single Place
	GetPlace(context.Context, *GetPlaceRequest) (*GetPlaceResponse, error)
	// Listen listens to Place updates and log output of a running Place
	Listen(*ListenRequest, CityService_ListenServer) error
	// StopPlace stops a currently running Place
	StopPlace(context.Context, *StopPlaceRequest) (*StopPlaceResponse, error)
	mustEmbedUnimplementedCityServiceServer()
}

// UnimplementedCityServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCityServiceServer struct {
}

func (UnimplementedCityServiceServer) StartLocalPlace(CityService_StartLocalPlaceServer) error {
	return status.Errorf(codes.Unimplemented, "method StartLocalPlace not implemented")
}
func (UnimplementedCityServiceServer) StartFromPreviousPlace(context.Context, *StartFromPreviousPlaceRequest) (*StartPlaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartFromPreviousPlace not implemented")
}
func (UnimplementedCityServiceServer) StartPlace(context.Context, *StartPlaceRequest) (*StartPlaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartPlace not implemented")
}
func (UnimplementedCityServiceServer) ListPlace(context.Context, *ListPlaceRequest) (*ListPlaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPlace not implemented")
}
func (UnimplementedCityServiceServer) Subscribe(*SubscribeRequest, CityService_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedCityServiceServer) GetPlace(context.Context, *GetPlaceRequest) (*GetPlaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlace not implemented")
}
func (UnimplementedCityServiceServer) Listen(*ListenRequest, CityService_ListenServer) error {
	return status.Errorf(codes.Unimplemented, "method Listen not implemented")
}
func (UnimplementedCityServiceServer) StopPlace(context.Context, *StopPlaceRequest) (*StopPlaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopPlace not implemented")
}
func (UnimplementedCityServiceServer) mustEmbedUnimplementedCityServiceServer() {}

// UnsafeCityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CityServiceServer will
// result in compilation errors.
type UnsafeCityServiceServer interface {
	mustEmbedUnimplementedCityServiceServer()
}

func RegisterCityServiceServer(s grpc.ServiceRegistrar, srv CityServiceServer) {
	s.RegisterService(&CityService_ServiceDesc, srv)
}

func _CityService_StartLocalPlace_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CityServiceServer).StartLocalPlace(&cityServiceStartLocalPlaceServer{stream})
}

type CityService_StartLocalPlaceServer interface {
	SendAndClose(*StartPlaceResponse) error
	Recv() (*StartLocalPlaceRequest, error)
	grpc.ServerStream
}

type cityServiceStartLocalPlaceServer struct {
	grpc.ServerStream
}

func (x *cityServiceStartLocalPlaceServer) SendAndClose(m *StartPlaceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cityServiceStartLocalPlaceServer) Recv() (*StartLocalPlaceRequest, error) {
	m := new(StartLocalPlaceRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CityService_StartFromPreviousPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartFromPreviousPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServiceServer).StartFromPreviousPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.CityService/StartFromPreviousPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServiceServer).StartFromPreviousPlace(ctx, req.(*StartFromPreviousPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CityService_StartPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServiceServer).StartPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.CityService/StartPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServiceServer).StartPlace(ctx, req.(*StartPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CityService_ListPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServiceServer).ListPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.CityService/ListPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServiceServer).ListPlace(ctx, req.(*ListPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CityService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServiceServer).Subscribe(m, &cityServiceSubscribeServer{stream})
}

type CityService_SubscribeServer interface {
	Send(*SubscribeResponse) error
	grpc.ServerStream
}

type cityServiceSubscribeServer struct {
	grpc.ServerStream
}

func (x *cityServiceSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CityService_GetPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServiceServer).GetPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.CityService/GetPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServiceServer).GetPlace(ctx, req.(*GetPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CityService_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CityServiceServer).Listen(m, &cityServiceListenServer{stream})
}

type CityService_ListenServer interface {
	Send(*ListenResponse) error
	grpc.ServerStream
}

type cityServiceListenServer struct {
	grpc.ServerStream
}

func (x *cityServiceListenServer) Send(m *ListenResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CityService_StopPlace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPlaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CityServiceServer).StopPlace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.CityService/StopPlace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CityServiceServer).StopPlace(ctx, req.(*StopPlaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CityService_ServiceDesc is the grpc.ServiceDesc for CityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.CityService",
	HandlerType: (*CityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartFromPreviousPlace",
			Handler:    _CityService_StartFromPreviousPlace_Handler,
		},
		{
			MethodName: "StartPlace",
			Handler:    _CityService_StartPlace_Handler,
		},
		{
			MethodName: "ListPlace",
			Handler:    _CityService_ListPlace_Handler,
		},
		{
			MethodName: "GetPlace",
			Handler:    _CityService_GetPlace_Handler,
		},
		{
			MethodName: "StopPlace",
			Handler:    _CityService_StopPlace_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StartLocalPlace",
			Handler:       _CityService_StartLocalPlace_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _CityService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Listen",
			Handler:       _CityService_Listen_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "city.proto",
}
